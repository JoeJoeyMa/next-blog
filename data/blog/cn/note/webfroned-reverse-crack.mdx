---
title: "前端逆向工程：从 Webpack/Vite 打包到滑块验证码与公私钥加密的全面解析"
date: "2024-12-18"
authors: ['MASON']
language: cn
summary: "深入探讨前端逆向工程实践，包括 Webpack/Vite 打包代码分析、滑块验证码自动化、RSA 加密实现等关键技术，以及如何将这些技术应用到实际项目中。"
tags: ["前端", "逆向工程", "Webpack", "Vite", "加密", "验证码", "JavaScript", "Node.js", "Python", "安全", "自动化"]
images: ['']
layout: PostLayout
---

# 前端逆向工程：从 Webpack/Vite 打包到滑块验证码与公私钥加密的全面解析

## 1. 前端逆向工程概述

前端逆向工程是指分析浏览器中运行的 JavaScript 代码，提取关键逻辑（如加密算法、验证码验证）并在其他环境中复用（如 Node.js）。随着 Webpack 和 Vite 等现代打包工具的广泛使用，前端代码通常被压缩、混淆，增加了逆向难度。本文基于某花顺登录滑块验证的案例，结合 Webpack 代码抠取技术，展示完整的逆向流程。

### 1.1 逆向目标

- **某花顺登录滑块逆向**：提取登录过程中的加密参数（如 `uname`、`passwdSalt`）和滑块验证码验证逻辑，实现自动化登录。
- **Webpack 代码抠取**：将 Webpack 打包的浏览器端代码移植到 Node.js 环境，调用关键函数（如 MD5、RSA 加密）。
- **公私钥加密**：分析 RSA 加密实现，探讨公钥指数固定的安全性。
- **滑块验证码**：理解为何验证码可用数据表示，并实现自动化识别。

### 1.2 工具准备

- **浏览器开发者工具**：
  - Chrome/Firefox DevTools，分析网络请求和 JavaScript 代码
  - 使用 Network 面板监控 API 请求
  - 使用 Sources 面板进行代码调试
  - 使用 Console 面板执行测试代码

- **反混淆工具**：
  - [de4js](https://de4js.com/)：美化压缩代码
  - [JS Beautifier](https://beautifier.io/)：格式化 JavaScript
  - [AST Explorer](https://astexplorer.net/)：分析代码结构

- **Source Map 工具**：
  - `unwebpack-sourcemap`：还原 Webpack Source Map
  - `source-map-explorer`：分析 bundle 结构
  - `webpack-bundle-analyzer`：可视化依赖关系

- **抓包工具**：
  - Fiddler：Windows 平台抓包
  - Burp Suite：跨平台抓包，支持 HTTPS
  - Charles：Mac 平台抓包

- **图像处理**：
  - Python 的 `ddddocr`：OCR 识别
  - `Pillow`：图像处理
  - `OpenCV`：计算机视觉

- **Node.js 环境**：
  - 运行逆向代码
  - 复用 Webpack 模块
  - 模拟浏览器环境

---

## 2. Webpack 与 Vite 打包代码的逆向

### 2.1 Webpack 打包特点

Webpack 是前端常用的模块打包工具，将 JavaScript、CSS 等资源打包为 bundle 文件（如 `main.js`）。其特点包括：

- **模块化**：
  - 使用 `__webpack_require__` 加载模块
  - 模块以数字 ID（如 `1337`）组织
  - 存储在 `window.webpackChunk` 或 `__webpack_modules__` 中

- **压缩与混淆**：
  - 生产模式下使用 Terser 压缩代码
  - 变量名缩短
  - 函数名重命名
  - 移除注释和空白

- **Source Map**：
  - 开发模式生成 `.map` 文件
  - 包含原始代码映射
  - 支持调试和错误追踪

- **动态导入**：
  - 支持代码分割
  - 生成 chunk 文件（如 `chunk-xxx.js`）
  - 按需加载优化性能

### 2.2 Vite 打包特点

Vite 基于 ES 模块（ESM）和 Rollup，特点如下：

- **ESM 驱动**：
  - 开发环境直接使用浏览器原生模块
  - 生产环境由 Rollup 打包
  - 更快的开发服务器启动

- **简洁 bundle**：
  - 相比 Webpack，代码结构更清晰
  - 混淆程度较低
  - 更好的可读性

- **依赖预打包**：
  - 将 `node_modules` 依赖打包到 `dist/assets` 中
  - 使用 esbuild 进行预构建
  - 提高开发环境性能

### 2.3 逆向步骤

#### 2.3.1 获取前端资源

- **打开 DevTools**：
  ```javascript
  // 禁用 F12 检测
  document.addEventListener('keydown', function(e) {
    if (e.key === 'F12') {
      e.preventDefault();
    }
  });
  ```

- **提取 Source Map**：
  ```bash
  # 安装工具
  npm install -g unwebpack-sourcemap
  
  # 还原代码
  unwebpack-sourcemap main.js.map
  
  # 分析 bundle
  npx source-map-explorer main.js.map
  ```

#### 2.3.2 反混淆代码

- **使用 de4js**：
  ```javascript
  // 压缩代码
  function a(b,c){return b+c}
  
  // 美化后
  function add(num1, num2) {
    return num1 + num2;
  }
  ```

#### 2.3.3 定位关键逻辑

- **搜索关键字**：
  ```javascript
  // 在某花顺案例中搜索
  thsencrypt
  passwdsalt
  ```

- **断点调试**：
  ```javascript
  // 在 DevTools 中设置条件断点
  if (plaintext === 'user@example.com') {
    debugger;
  }
  ```

- **模块结构**：
  ```javascript
  // Webpack 模块注册
  (window.webpackChunk = window.webpackChunk || []).push([[245], {
    245: (module, exports, __webpack_require__) => {
      module.exports = { 
        encode: function(plaintext) {
          // 加密逻辑
        } 
      };
    }
  }]);
  ```

#### 2.3.4 提取 Webpack 运行时

- **定位 __webpack_require__**：
  ```javascript
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = { exports: {} };
    __webpack_modules__[moduleId].call(
      module.exports, 
      module, 
      module.exports, 
      __webpack_require__
    );
    return module.exports;
  }
  ```

- **全局导出**：
  ```javascript
  // 添加全局访问
  globalThis.__exposedWebpackRequire = __webpack_require__;
  ```

#### 2.3.5 收集依赖模块

- **设置日志断点**：
  ```javascript
  // 在 __webpack_require__ 中添加日志
  window.module_array += moduleId + ':' + __webpack_modules__[moduleId] + ',\n';
  
  // 清空缓存强制加载
  __webpack_module_cache__ = {};
  ```

#### 2.3.6 补环境

- **模拟浏览器环境**：
  ```javascript
  // Node.js 环境补丁
  global.self = global;
  global.window = global;
  global.navigator = { 
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' 
  };
  global.document = {
    createEvent: () => ({ 
      timeStamp: Number(process.hrtime.bigint() / 1_000_000n) 
    })
  };
  ```

#### 2.3.7 在 Node.js 中运行

- **编写运行脚本**：
  ```javascript
  // run_encrypt.js
  global.self = global;
  require('./main.bundle.js');
  require('./chunk-xxx.js');
  
  let __webpack_require__ = globalThis.__exposedWebpackRequire;
  let module_xxx = __webpack_require__('xxx');
  console.log(module_xxx.encode('user@example.com'));
  ```

---

## 3. 某花顺登录滑块逆向

### 3.1 背景

某花顺登录涉及账号密码加密和滑块验证码验证，核心目标是：
加密 uname 和 passwdSalt 参数，发送到 getGS 和 dologinreturnjson2 接口。
自动识别滑块验证码，生成验证参数（如 phrase 和 signature）。

### 3.2 加密逻辑

#### 3.2.1 RSA 加密

前端实现：使用 thsencrypt.encode 函数，基于 RSA 算法加密账号和密码：

```javascript
var thsencrypt = {
  encode: function(plaintext, modulus_hex, exponent_hex) {
    var rsa = new JSEncrypt();
    rsa.setPublicKey(modulus_hex, exponent_hex);
    return rsa.encrypt(plaintext);
  }
};
var uname = thsencrypt.encode('user@example.com', 'YOUR_MODULUS', '10001');
```

Python 还原：

```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from base64 import b64encode

def encrypt_encode(plaintext: str) -> str:
    modulus_hex = "YOUR_MODULUS_HERE"  # 从 getGS 获取
    exponent_hex = "10001"
    modulus = int(modulus_hex, 16)
    exponent = int(exponent_hex, 16)
    key = RSA.construct((modulus, exponent))
    cipher = PKCS1_v1_5.new(key)
    plaintext_bytes = plaintext.encode('utf-8')
    encrypted_bytes = cipher.encrypt(plaintext_bytes)
    return b64encode(encrypted_bytes).decode('utf-8')
```

密码加密：密码先经过 MD5 加密：

```python
import hashlib
def hex_md5(text: str) -> str:
    return hashlib.md5(text.encode('utf-8')).hexdigest().lower()
passwd_md5 = hex_md5('mypassword')
passwd_encrypted = encrypt_encode(passwd_md5)
```

#### 3.2.2 passwdSalt 生成

逻辑：涉及 MD5、HmacSHA256 和 XOR 操作：

```python
import hmac
import hashlib
from base64 import b64decode, b64encode

def get_str_xor(e: str, t: str) -> str:
    s = len(e)
    r = len(t)
    o = []
    for d in range(s):
        n = d % r
        xor_char = chr(ord(e[d]) ^ ord(t[n]))
        o.append(xor_char)
    return ''.join(o)

def encode_data_salt_once(passwd: str, uname: str, crnd: str, dsk: str, ssv: str, dsv: str) -> str:
    n = hashlib.sha256((crnd + dsk).encode('utf-8')).hexdigest()
    ssv_decoded = b64decode(ssv).decode('utf-8')
    n = get_str_xor(n, ssv_decoded)
    passwd_md5 = hex_md5(passwd)
    n = hmac.new(n.encode('utf-8'), passwd_md5.encode('utf-8'), hashlib.sha256).hexdigest()
    dsv_sha256 = hashlib.sha256(dsv.encode('utf-8')).hexdigest()
    n = get_str_xor(n, dsv_sha256)
    n = b64encode(n.encode('utf-8')).decode('utf-8')
    return encrypt_encode(n)
```

### 3.3 滑块验证码实现

#### 3.3.1 验证码分析

滑块验证码的核心是验证用户滑动轨迹是否合法。主要验证点包括：

1. **轨迹数据**：
   - 滑动距离
   - 滑动时间
   - 加速度变化
   - 轨迹点分布

2. **特征提取**：
   ```python
   def extract_track_features(track_points):
       features = {
           'distance': calculate_distance(track_points),
           'duration': track_points[-1]['timestamp'] - track_points[0]['timestamp'],
           'acceleration': calculate_acceleration(track_points),
           'point_count': len(track_points)
       }
       return features
   ```

3. **轨迹生成**：
   ```python
   def generate_human_like_track(distance: int) -> List[Dict]:
       track = []
       current_x = 0
       current_time = int(time.time() * 1000)
       
       # 初始加速
       for i in range(5):
           current_x += random.randint(2, 4)
           current_time += random.randint(10, 20)
           track.append({'x': current_x, 'y': 0, 'timestamp': current_time})
           
       # 匀速滑动
       while current_x < distance - 10:
           current_x += random.randint(1, 3)
           current_time += random.randint(15, 25)
           track.append({'x': current_x, 'y': 0, 'timestamp': current_time})
           
       # 减速
       while current_x < distance:
           current_x += random.randint(0, 2)
           current_time += random.randint(20, 30)
           track.append({'x': current_x, 'y': 0, 'timestamp': current_time})
           
       return track
   ```

#### 3.3.2 验证码绕过

1. **图像识别**：
   ```python
   import ddddocr
   
   def get_slider_distance(bg_image: bytes, slider_image: bytes) -> int:
       ocr = ddddocr.DdddOcr(det=False, ocr=False, show_ad=False)
       res = ocr.slide_match(bg_image, slider_image, simple_target=True)
       return res['target'][0]
   ```

2. **轨迹优化**：
   ```python
   def optimize_track(track: List[Dict], target_distance: int) -> List[Dict]:
       # 调整轨迹点分布
       optimized = []
       for point in track:
           # 添加随机偏移
           point['y'] = random.randint(-2, 2)
           # 调整时间间隔
           point['timestamp'] += random.randint(-5, 5)
           optimized.append(point)
       return optimized
   ```

3. **请求构造**：
   ```python
   def construct_verify_request(track: List[Dict], distance: int) -> Dict:
       return {
           'phrase': base64.b64encode(json.dumps(track).encode()).decode(),
           'signature': calculate_signature(track, distance),
           'distance': distance
       }
   ```

### 3.4 完整登录流程

```python
async def login(username: str, password: str) -> Dict:
    # 1. 获取加密参数
    gs_response = await get_gs()
    modulus = gs_response['modulus']
    crnd = gs_response['crnd']
    
    # 2. 加密用户名和密码
    encrypted_username = encrypt_encode(username, modulus)
    encrypted_password = encrypt_encode(hex_md5(password), modulus)
    
    # 3. 生成 passwdSalt
    passwd_salt = encode_data_salt_once(
        password, username, crnd,
        gs_response['dsk'],
        gs_response['ssv'],
        gs_response['dsv']
    )
    
    # 4. 处理滑块验证码
    slider_data = await get_slider()
    distance = get_slider_distance(slider_data['bg'], slider_data['slider'])
    track = generate_human_like_track(distance)
    verify_data = construct_verify_request(track, distance)
    
    # 5. 发送登录请求
    login_data = {
        'uname': encrypted_username,
        'passwd': encrypted_password,
        'passwdSalt': passwd_salt,
        **verify_data
    }
    
    return await send_login_request(login_data)
```

## 4. 安全建议

### 4.1 前端加密

1. **避免固定公钥**：
   - 定期更换 RSA 密钥对
   - 使用动态生成的密钥
   - 考虑使用非对称加密的其他方案

2. **增加验证复杂度**：
   - 添加时间戳验证
   - 使用动态盐值
   - 实现请求签名机制

3. **混淆保护**：
   - 使用 JavaScript 混淆工具
   - 实现代码自修改
   - 添加反调试机制

### 4.2 验证码优化

1. **轨迹验证**：
   - 增加轨迹点验证
   - 添加加速度检测
   - 实现轨迹特征分析

2. **图像处理**：
   - 增加图像干扰
   - 使用动态背景
   - 实现多图验证

3. **行为分析**：
   - 记录用户行为特征
   - 实现风险评分
   - 添加二次验证

## 5. 总结

前端逆向工程是一个复杂而有趣的技术领域，需要深入理解前端框架、加密算法和验证码机制。通过本文的案例，我们展示了：

1. **Webpack/Vite 打包代码的逆向方法**
2. **RSA 加密算法的实现和安全性分析**
3. **滑块验证码的自动化解决方案**
4. **完整登录流程的实现**

在实际应用中，我们需要在安全性和用户体验之间找到平衡，既要保护系统安全，又要确保良好的用户体验。同时，也要注意逆向工程的法律和道德边界，确保技术的合理使用。

---

*注：本文仅用于技术研究和学习目的，请勿用于非法用途。在实际项目中，建议采用更安全的加密方案和验证机制。*